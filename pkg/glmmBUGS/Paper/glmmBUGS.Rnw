\documentclass{article}
\usepackage{graphicx}
\textwidth 6.0 true in
\textheight 9 true in
\topmargin -1.0 true in
\headsep 0.375 true in
\oddsidemargin 0.0 true in
\evensidemargin 0.5 true in

\title{An Introduction to glmmBUGS Package}
\begin{document}
\maketitle

\large
\section{Introduction}
 


\section{Key Functions and Examples}
The primary function defined in package \textit{glmmBUGS} is the model-fitting function of the same name.
This function is \textit{glmmBUGS}. 

We will consider two types of data set in this paper: non-spatial data set and spatial data set.

\subsection{Non-spatial Model} 
We took the bacteria data from library \textit{MASS} as an example of non-spatial data set: 
Here is how the data looks like : 
<<thedata1>>=
library(MASS)
head(bacteria)
@

\begin{itemize}
\item y : presence or absence: a factor with levels n and y. 
\item ap : active/placebo: a factor with levels a and p. 
\item hilo : hi/low compliance: a factor with levels hi amd lo. 
\item week : numeric: week of test. 
\item ID : subject ID: a factor. 
item trt: a factor with levels placebo, drug and drug+, a re-coding of ap and hilo. 
\end{itemize} 

We fit a generalized linear mixed model as: 

\[Y_{ij} \sim  Bernoulli(p_{ij})\]
\[logit(p_{ij}) = x_{ij}\beta + V_{i}\]
\[V_{i} \sim iid N(0, \sigma^2)\] 

where $Y_{ij}$ is the presence or absence of bacteria with covariates $x_{ij}$ (treatment and week).  
$p_{ij}$ denotes the patient $i$ of treatment and week effect $j$ has bacteria.
$V_i$ is the random intercept for $ith$ patient, which follows an identical independent normal distribution with mean equals 0 and variance of $\sigma_V^2$.


Base on the theoretical model above, we could fit a glmmBUGS model as: 
<<thecode>>=
bacrag <- glmmBUGS(y ~ trt + week , data=bacteria, effects = "ID", family= "bernoulli") 


To aid in convergence, the bugs model is actually the following:

\[Y_{ij} \sim  Bernoulli(p_{ij})\]
\[logit(p_{ij}) = R_{ij}\]
\[R_{ij} \sim N(x_{ij}\beta, \sigma^2)\]
\[V_{i} = R_{ij} - x_{ij}\beta \] 

The response variable \textit{y} is a factor variable, but winBUGS can only handle numerical variable. Therefore, we change it to numerics 0 and 1.$1$ denotes ''y'' and 0 denotes ''n''. We named the new column ''yInt''.  In the ''trt'' column, there are three 
levels of treatments, one of them is ''drug+'', we change it to ''drugplus'' for fitting the glmmBUGS model.
<<>>=
bacterianew <- bacteria
bacterianew$yInt = as.integer(bacteria$y=="y")
levels(bacterianew$trt) <- c("placebo", "drug", "drugplus")

After the above changes, the data set looks like: 
<<newdata>>=
head(bacterianew)
@

We fit the glmmBUGS model using the above data set as: 
<<bacrag>>=
bacrag <- glmmBUGS(yInt ~ trt + week , data=bacteria, effects = "ID", 
                                                 family= "bernoulli") 
@

The \verb!yInt! is the predicted value. 
The \verb!trt + week! are the prediction values
The \verb!effects! arguments specified the random intercept term.

<<raggedArray>>=
names(bacrag$ragged)
@

We get three sets of results from glmmBUGS fuction: ragged, startingValues and pql. 
\textit{ragged} is a matrix that contains the data which can be used in winBUGS in the future step. 
\textit{pql} is the results from the \textit{glmmPQL} function in the \textit{MASS} package.
\textit{startingValues} provides the starting values of the MCMC simulation runs by winBUGS, which is obtained using penalized-quasi-likelihood from \verb!glmmPQL! function.  


After running \textit{glmmBUGS} function, we will use \textit{bugs} function in \textit{R2WinBUGS} package
to call the winBUGS do the MCMC simulation as: 

<<thebug>>=
library(R2WinBUGS)
bacResult = bugs(bacrag$ragged, getInits, parameters.to.save = names(getInits()),
                 model.file="model.bug", n.chain=3, 
                 n.iter=1000, n.burnin=100, n.thin=10, program="winbugs", debug=T)


The data used for \textit{bugs} function is the \verb!ragged! from the \textit{glmmBUGS} function. 
The \verb!getInits! is generated from the \textit{glmmBUGS} function and it gives the starting values for the simulation. 
\verb!parameters.to.save! is a character vector of the names of the parameters to be saved.
\verb!model.file! is the file which contains the code used for WinBUGS
\verb!n.chain! denotes how many chains used to ran for the simulation, it is $3$ as default.
\verb!n.iter! denotes the number of total iterations per chain; 
\verb!n.burnin! denotes number of iterations to discard at the beginning; 
\verb!n.thin! denotes the thinning rate. So for our example, we will get $270$ simulation results.

As we run the \verb!bugs! function, a winbugs window will open and do the simulation of the posterior distribution.

All the results are now stored in the bacResult, but it is hard to get them out, we need to use  \textit{restoreParams} function to restore the parameters as: 

<<theparam>>=
bacParams = restoreParams(bacResult, bacrag$ragged) 
names(bacParams)
@ 


The ''intercept'' column contains $270$ values of simulated intercept values. 
''SDID'' is the standard deviation of patient's ID. 
''RID'' is the non-spatial effect, i.e $V_i$
''betas'' are the simulated estimators of the coefficients of treatment and number of weeks. 

After all the results are stored properly, we need to do a summary on all the results, that will be easier for us to grab information from the simulation results. \verb!summarychain! function will be used for this purpose.

<<thesummary>>=
bacsummary = summaryChain(bacParams)
names(bacsummary)
@



\verb!bacsummary! contains the three results: scalars, RID and betas. Each result has the mean values, standard deviation values, p-values and the confidence interval values on different scale levels for the parameters stored in the \verb!restoreParams! function. 
For example, the ''betas'' gives the following results:
<<thebeta>>=
bacsummary$betas
@                     
                                                                                   

 

In order to check the convergency of the simulation, we use \textit{checkChain(bacParams)} function to do the chain plot:
<<thechain>>=
checkChain(bacParams)




\begin{figure}[ht]
 \centering
 <<fig=TRUE, width=12, height=6>>=
 chechChain(bacParams)
 @
 \caption{A chain plot of the posterial distribution from MCMC simulation for the non-spatial model.}\label{chain}
\end{figure}

The plot is shown in Figure \ref{chain}. The three lines (red, green and black lines) are converges, this means the simulation result are stable. 



\subsection{Spatial Model} 
We then introduce the spatial model. The data set is built in the \textit{glmmBUGS} package. 

<<thedata>>
head(ontario)
@

$CSDUID$ is the census tract number; 
$Observed$ is the number of cancer cases; 
$logExpected$ is the predicted number of cancer cases on the $\log$ scale.

Consider the following model, where $Y_{ijk}$ is the number of cancer cases from individual i from age and sex group j in census k.  

\[Y_{ij} \sim  Poisson(\lambda_i)\]
\[\log(\lambda_i) = \mu + U_i + V_{ij}+ \log{O_i}\]
\[U_i \sim GMRF(0, \sigma_U^2)\]
\[V_i \sim iid N(0, \sigma_V^2)\] 

where $Y_i$ denotes the number of cancer cases;  
$\lambda$ is the rate of disease, it is the mean and variance of the poisson distribution; 
$\mu$ is the average of disease rate when other effects were not in the consideration.
$U_i$ denotes the spatial term, it follows a gussian markov random field with mean equals $0$ and variance $\sigma_U^2$; 
$V_{ij}$ denotes the non-spatial term, it follows an identical independent distribution with mean equals $0$ and variance equals $\sigma_V^2$; 
$\log{O_i}$ is the offset.


To aid in convergence, the bugs model is actually the following:
\[Y_{ij} \sim  Poisson(\lambda_i)\]
\[\log(\lambda_i) = R_i+ \log{O_i}\]
\[R_i \sim N(U_i + \mu, \sigma_U^2)\]
\[U_i \sim GMRF(0, \sigma_U^2)\]
\[V_{i} = R_i - U_i \sim iid N(0, \sigma_V^2)\] 

The spatial term $U_i$ in the model relects the effects from neighbours. We use a adjancy matrix to denote this effects by using the \verb!poly2nb! function from the \verb!spdep! library. 

<<thepopadj>>=
library(spdep)
popDataAdjMat = poly2nb(popdata, as.character(popdata[["CSDUID"]]))

Then we fit a glmmBUGS model: 
<<theragged>>=
forBugs = glmmBUGS(formula=Observed + logExpected ~ 1,
  effects="CSDUID", family="poisson", spatial=popDataAdjMat,
  data=ontario)

The $\log$ of the expected values of cancer cases as offset value; The spatial terms equals the adjancy matrix. The random effects is the region code.

Then we use the \verb!bugs! function to do the MCMC simulation as: 
<<thebugs>>=
ontarioResult = bugs(forBugs$ragged, getInits, parameters.to.save = names(getInits()),
   model.file="model.bug", n.chain=3, n.iter=6000, n.burnin=100, n.thin=50,
       program="winbugs")


<<theparams>>=
names(ontarioParams)
@     

Compare the paramters we got from the spatial model with the parameters from the non-spatial model. 
There are three extra terms: SDCSUIDSpatial, RCSUIDSpatial and FittedRateCSDUID.

SDCSUIDSpatial     The standard deviation of the spatial effects for each region.
RCSDUIDSpatial     The spatial random effect for each region. 
FittedRateCSDUID   The incident rate relative to the population average. Note that these rates are on the natural scale rather than the log scale. 

%RCSDUID            The log relative risk, which is the sum of the spatial and non-spatial random effect, i.e $U_i + V_i$. 

<<thesummary>>=
ontarioSummary = summaryChain(ontarioParams)
checkChain(ontarioParams)
@

\begin{figure}[ht]
 \centering
 <<fig=TRUE, width=12, height=6>>=
 chechChain(ontarioParams)
 @
 \caption{A chain plot of the posterial distribution from MCMC simulation for the spatial model.}\label{chainspatial}
\end{figure}

Figure \ref{chainspatial} shows the chain plots for the spatial model. The sdandard deviation of the region and spatial effect converges well, but the intercept values doesn't converge well. In general, the three chains don't converge well could because of the size of the simulation, it means the predicted value is not stable.

\section{Summary}

\section{Acknowledgments}


\section{Bibliography}


\end{document}



