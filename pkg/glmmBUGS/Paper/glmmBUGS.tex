\documentclass{article}
\usepackage{graphicx}
\textwidth 6.0 true in
\textheight 9 true in
\topmargin -1.0 true in
\headsep 0.375 true in
\oddsidemargin 0.0 true in
\evensidemargin 0.5 true in

\title{An Introduction to glmmBUGS Package}
\begin{document}
\maketitle

\large
\section{Introduction}
 


\section{Key Functions and Examples}
The primary function defined in package \textit{glmmBUGS} is the model-fitting function of the same name.
This function is \textit{glmmBUGS}. 

We will consider two types of data set in this paper: non-spatial data set and spatial data set.

\subsection{Non-spatial Model} 
We took the bacteria data from library \textit{MASS} as an example of non-spatial data set: 
Here is how the data looks like : 
\begin{verbatim}
  y ap hilo week  ID     trt
1 y  p   hi    0 X01 placebo
2 y  p   hi    2 X01 placebo
3 y  p   hi    4 X01 placebo
4 y  p   hi   11 X01 placebo
5 y  a   hi    0 X02   drug+
6 y  a   hi    2 X02   drug+
\end{verbatim}
\begin{itemize}
\item y : presence or absence: a factor with levels n and y. 
\item ap : active/placebo: a factor with levels a and p. 
\item hilo : hi/low compliance: a factor with levels hi amd lo. 
\item week : numeric: week of test. 
\item ID : subject ID: a factor. 
item trt: a factor with levels placebo, drug and drug+, a re-coding of ap and hilo. 
\end{itemize} 

We fit a generalized linear mixed model as: 

\[Y_{ij} \sim  Bernoulli(p_{ij})\]
\[logit(p_{ij}) = x_{ij}\beta + V_{i}\]
\[V_{i} \sim iid N(0, \sigma^2)\] 

where $Y_{ij}$ is the presence or absence of bacteria with covariates $x_{ij}$ (treatment and week).  
$p_{ij}$ denotes the patient $i$ of treatment and week effect $j$ has bacteria.
$V_i$ is the random intercept for $ith$ patient, which follows an identical independent normal distribution with mean equals 0 and variance of $\sigma_V^2$.

Base on the theoretical model above, we could fit a glmmBUGS model as: 
\begin{verbatim}
bacrag <- glmmBUGS(y ~ trt + week , data=bacteria, effects = "ID", family= "bernoulli") 
\end{verbatim}
To aid in convergence, the bugs model is actually the following:

\[Y_{ij} \sim  Bernoulli(p_{ij})\]
\[logit(p_{ij}) = R_{ij}\]
\[R_{ij} \sim N(x_{ij}\beta, \sigma^2})\]
\[V_{i} = R_{ij} - x_{ij}\beta \] 

The response variable \textit{y} is a factor variable, but winBUGS can only handle numerical variable. Therefore, we change it to numerics 0 and 1.$1$ denotes ''y'' and 0 denotes ''n''. We named the new column ''yInt''.  In the ''trt'' column, there are three 
levels of treatments, one of them is ''drug+'', we change it to ''drugplus'' for fitting the glmmBUGS model.

After the above changes, the data set looks like: 

<<thedata>>=
head(bacteria)
@


\begin{verbatim}
 y ap hilo week  ID      trt yInt
 y  p   hi    0 X01  placebo    1
 y  p   hi    2 X01  placebo    1
 y  p   hi    4 X01  placebo    1
 y  p   hi   11 X01  placebo    1
 y  a   hi    0 X02 drugplus    1
 y  a   hi    2 X02 drugplus    1
\end{verbatim}

We fit the glmmBUGS model as: 
\begin{verbatim}
bacrag <- glmmBUGS(yInt ~ trt + week , data=bacteria, effects = "ID", family= "bernoulli") 
Loading required package: nlme
iteration 1
iteration 2
iteration 3
iteration 4
iteration 5
iteration 6
\end{verbatim}

The ''effects'' arguments specified the random intercept term.
<<raggedArray>>=
names(bacrag$ragged)
@


We will get three sets of results from glmmBUGS fuction as: ragged, startingValues and pql. 
\textit{ragged} is a matrix that contains the data which can be used in winBUGS in the future step. 
\textit{pql} is the results from the \textit{glmmPQL} function in the \textit{MASS} package.
\textit{startingValues} provides the starting values of the MCMC simulation runs by winBUGS, which is obtained using penalized-quasi-likelihood from \verb!glmmPQL! function.  


After running \textit{glmmBUGS} function, we will use \texit{bugs} function in \textit{R2WinBUGS} package
to call the winBUGS as: 
\begin{verbatim}
library(R2WinBUGS)
bacResult = bugs(bacrag$ragged, getInits, parameters.to.save = names(getInits()),
                 model.file="model.bug", n.chain=3, 
                 n.iter=1000, n.burnin=100, n.thin=10, program="winbugs", debug=T)
\end{verbatim}
The data used for \textit{bugs} function is the \verb!ragged! from the \textit{glmmBUGS} function. The \verb!getInits! is generated from the \textit{glmmBUGS} function and it gives the starting values for the simulation. \verb!n.chain! denotes how many chains the user want to ran for the simulation, it is $3$ as default. \verb!n.iter!
denotes the number of total iterations per chain; \verb!n.burnin! denotes number of iterations to discard at the beginning; \verb!n.thin! denotes the thinning rate. So for our example, we will get $270$ simulation results.

As we run the \verb!bugs! function, a winbugs window will open and do the simulation of the posterior distribution.

All the results are now stored in the bacResult, but it is hard to get them out, we need to use  \textit{restoreParams} function to restore the parameters as: 

\begin{verbatim}
bacParams = restoreParams(bacResult, bacrag$ragged) 
names(bacParams)
[1] "intercept" "SDID"      "deviance"  "RID"       "betas"    
\end{verbatim}

The ''intercept'' column contains $270$ values of simulated intercept values. ''SDID'' is the standard deviation of patient's ID. 
''betas'' are the simulated estimators of the coefficients of treatment and number of weeks. 

After all the results are stored properly, we need to do a summary on all the results, that will be easier for us to grab information from the simulation results. \verb!summarychain! function will be used for this purpose.
\begin{verbatim}
bacsummary = summaryChain(bacParams)
> names(bacsummary)
[1] "scalars" "RID"     "betas"  

\end{verbatim}


\verb!bacsummary! contains the three results: scalars, RID and betas. Each result has the mean values, standard deviation values, p-values and the confidence interval values on different scale levels for the parameters stored in the \verb!restoreParams! function. 
For example, the ''betas'' gives the following results:
\begin{verbatim}
> bacsummary$betas
                   mean       pval         sd      0.5%      2.5%        5%      50%
observations -0.1633777 0.00000000 0.05213974 -0.282689 -0.263855 -0.249555 -0.16685
trtdrug      -1.5128799 0.04074074 0.93333991 -4.236200 -3.558175 -3.213950 -1.42100
trtdrugplus  -0.9720788 0.11851852 0.84176339 -3.129370 -2.697575 -2.389500 -0.91915
                    95%      97.5%       99.5%
observations -0.0753595 -0.0611485 -0.03385445
trtdrug      -0.0980510  0.2515025  0.64842200
trtdrugplus   0.5102300  0.6130100  0.83561500

\end{verbatim}
 

In order to check the convergency of the simulation, we use \textit{checkChain(bacParams)} function to do the chain plot:
\begin{verbatim}
checkChain(bacParams)
\end{verbatim}



\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.3]{chain.pdf}
\caption{A chain plot of the posterial distribution from MCMC simulation.}\label{chain}
\end{center}
\end{figure}

The plot is shown in Figure \ref{chain}. The three lines (red, green and black lines) are converges, this means the simulation result are stable. 

\subsection{Spatial Model} 
We then introduce the spatial model. The data sets are from the \textit{diseasemapping} package. 
The case data set is the cases of Hepatitis Z in Ontario. 
<<thedata>>=
head(casedata)
@




 The population data is from the 2006 Census of canada offering by Statistics Canada web site, \code {www12.statcan.gc.ca/english/census06/data/highlights/agesex/Index_PR.cfm?Lang=E&Geo=CSD&Table=1
 
<<thedata>>
head(popdata@data)
@



Consider the following model, where $Y_{ijk}$ is the number of cancer cases from individual i from age and sex group j in census k.  

\[Y_{ij} \sim  Poisson(\lambda_i)\]
\[\log(\lambda_i) = \mu + U_i + V_{ij}+ \log{O_i}\]
\[U_i \sim GMRF(0, \sigma_U^2)\]
\[V_{i} \sim iid N(0, \sigma_V^2)\] 

where $\lambda$ is the rate of disease; $\mu$ is the average of disease rate when other effects were not in the consideration.
$U_i$ denotes the spatial term; $V_{ij}$ denotes the non-spatial term; $\log{O_i}$ is the offset.

The spatial term $U_i$ in the model relects the effects from neighbours. We use a adjancy matrix to denote this relationship by using the \verb!poly2nb! function from the \verb!spdep! library. 

\begin{verbatim}
library(spdep)
popDataAdjMat = poly2nb(popdata, as.character(popdata[["CSDUID"]]))
\end{verbatim}

Then we fit a glmmBUGS model with spatial terms equals the adjancy matrix.
\begin{verbatim}
forBugs = glmmBUGS(formula=Observed + logExpected ~ 1,
  effects="CSDUID",   family="poisson", spatial=popDataAdjMat,
  data=ontario)
\end{verbatim}
To aid in convergence, the bugs model is actually the following:

\[Y_{ij} \sim  Poisson(\lambda_i)\]
\[\log(\lambda_i) = R_i+ \log{O_i}\]
\[R_i \sim N(U_i + \mu, \sigma_U^2)\]
\[U_i \sim GMRF(0, \sigma_U^2)\]
\[V_{i} = R_i - U_i \sim iid N(0, \sigma_V^2)\] 


\section{Summary}

\section{Acknowledgments}


\section{Bibliography}


\end{document}



