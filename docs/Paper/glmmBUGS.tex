\documentclass{article}
\usepackage{graphicx}
\textwidth 6.0 true in
\textheight 9 true in
\topmargin -1.0 true in
\headsep 0.375 true in
\oddsidemargin 0.0 true in
\evensidemargin 0.5 true in

\title{An Introduction to glmmBUGS Package}
\usepackage{Sweave}
\begin{document}
\maketitle

\large
\section{Introduction}
The \verb!glmmBUGS! package, is a bridging tool between glmm (Generalized Linear Mixed Model) and BUGS (WinBUGS).
Generalized Linear Mixed Model is an extension to Generalized Linear Model (glm) in which the linear predictor contains random effects
in addition to the usual fixed effects:
\[Y = x_{ij}\beta + v_i\]
where $x_{ij}$ are the fixed effects and $v_i$ is the random effect, and it is usually assumed to be distributed as $N(0, \sigma_v^2)$.
WinBUGS is a statistical software for MCMC based Bayesian modelling using Gibbs Sampler.


The \verb!glmmBUGS! package provides facilities for preparing data for WinBUGS, wrtting BUGS models, getting the results from glmm fit and using them as starting values for MCMC chains in WinBUGS.
Models can be generated by typical glmm formulas, contains both fixed effects and offset while the random effect could be specified by the argument ''effect''.
The model can fit spatial data set using the argument ''spatial'' and ''spatial effect''.
After running the simulation in WinBGUS, the \verb!glmmBUGS! package also provide the function to restore the
parameters as function \verb!restoreParam! and to tidy up the simulation result using function \verb!summaryChain!.
In next section we will introduce the key functions in the package and provide some illustrative applications.

\section{Key Functions and Examples}
The primary function defined in package \verb!glmmBUGS! is a model-fitting function.
We will consider two types of datasets in this paper: a non-spatial dataset and a spatial dataset.

\subsection{Non-spatial Model} 
We took the bacteria data from library \verb!MASS! as an example of a non-spatial model fitting:
Here is how the data looks like : 
\begin{Schunk}
\begin{Sinput}
> library(MASS)
> data(bacteria)
> head(bacteria)
\end{Sinput}
\begin{Soutput}
  y ap hilo week  ID     trt
1 y  p   hi    0 X01 placebo
2 y  p   hi    2 X01 placebo
3 y  p   hi    4 X01 placebo
4 y  p   hi   11 X01 placebo
5 y  a   hi    0 X02   drug+
6 y  a   hi    2 X02   drug+
\end{Soutput}
\end{Schunk}

\begin{itemize}
\item y : presence or absence: a factor with levels ``n'' and ``y''.
\item ap : active or placebo: a factor with levels ``a'' and ``p''.
\item hilo : hi or low compliance: a factor with levels ``hi'' and ``lo''.
\item week : numeric: week of test. 
\item ID : subject ID: a factor indicates patient's ID number. 
\item trt: a factor with levels ``placebo'', ``drug'' and ``drug+'', a re-coding of the variables ap and hilo.
\end{itemize} 

We fit the above dataset using a generalized linear mixed model as follows:

\[Y_{ij} \sim  Bernoulli(p_{ij})\]
\[logit(p_{ij}) = x_{ij}\beta + V_{i}\]
\[V_{i} \sim iid N(0, \sigma^2)\] 

where $Y_{ij}$ is the presence or absence of bacteria of $ith$ person at week $j$ with covariates $x_{ij}$ (treatment and week).
$p_{ij}$ denotes the probability if bacteria presence of patient $i$ at week $j$.
$V_i$ is the random intercept for $ith$ patient, which follows an identical independent normal distribution with mean equals $0$ and variance of $\sigma^2$.

%Base on the theoretical model above, we could fit a glmmBUGS model as: 
%<<thecode>>=
%bacrag <- glmmBUGS(y ~ trt + week , data=bacteria, effects = "ID", family= "bernoulli") 
%@

To aid the convergence, the winBUGS is actually fitting the reparameterized model:

\[Y_{ij} \sim  Bernoulli(p_{ij})\]
\[logit(p_{ij}) = R_{ij}\]
\[R_{ij} \sim N(x_{ij}\beta, \sigma^2)\]
\[V_{i} = R_{ij} - x_{ij}\beta \] 

The response variable $''Y_{ij}''$ is a factor variable, but winBUGS can only handle numerical variable. Therefore, it needs to change to numerics $0$ and $1$. $1$ denotes ''y'' and $0$ denotes ''n''. We named the new column ''yInt''.  In the ''trt'' column, there are three 
levels of treatments, one of them is ''drug+'', we change it to ''drugplus'' for fitting the glmmBUGS model.

\begin{Schunk}
\begin{Sinput}
> bacterianew <- bacteria
> bacterianew$yInt = as.integer(bacteria$y == "y")
> levels(bacterianew$trt) <- c("placebo", "drug", "drugplus")
\end{Sinput}
\end{Schunk}

After the above changes, the data set looks like: 
\begin{Schunk}
\begin{Sinput}
> head(bacterianew)
\end{Sinput}
\begin{Soutput}
  y ap hilo week  ID      trt yInt
1 y  p   hi    0 X01  placebo    1
2 y  p   hi    2 X01  placebo    1
3 y  p   hi    4 X01  placebo    1
4 y  p   hi   11 X01  placebo    1
5 y  a   hi    0 X02 drugplus    1
6 y  a   hi    2 X02 drugplus    1
\end{Soutput}
\end{Schunk}

We fit the glmmBUGS model using the above data set as: 
\begin{Schunk}
\begin{Sinput}
> library(glmmBUGS)
> bacrag <- glmmBUGS(yInt ~ trt + week, data = bacterianew, effects = "ID", 
+     family = "bernoulli")
\end{Sinput}
\end{Schunk}

The \verb!yInt! is the response variable. 
The \verb!trt + week! are the fixed effects
The \verb!effects! arguments specified the random intercept.

\begin{Schunk}
\begin{Sinput}
> names(bacrag)
\end{Sinput}
\begin{Soutput}
[1] "ragged"         "startingValues" "pql"           
\end{Soutput}
\end{Schunk}

We get three sets of results from glmmBUGS function: ragged, startingValues and pql. 
\textit{ragged} is a matrix that contains the data which will be used in winBUGS in the future step. 
\textit{pql} is the results from the \verb!glmmPQL! function in the \verb!MASS! package.
\textit{startingValues} provides the starting values of the MCMC simulation runs by winBUGS, which is obtained using penalized-quasi-likelihood from \verb!glmmPQL! function.  


After running \verb!glmmBUGS! function, we will use \verb!bugs! function in \verb!R2WinBUGS! package
to call the winBUGS do the MCMC simulation as: 

\begin{Schunk}
\begin{Sinput}
> startingValues = bacrag$startingValues
> source("getInits.R")
> library(R2WinBUGS)
> bacResult = bugs(bacrag$ragged, getInits, parameters.to.save = names(getInits()), 
+     model.file = "model.bug", n.chain = 3, n.iter = 1000, n.burnin = 100, 
+     n.thin = 10, program = "winbugs", debug = T)
\end{Sinput}
\end{Schunk}

The data used for \textit{bugs} function is the \verb!ragged! from the \textit{glmmBUGS} function. 
The \verb!getInits! is written by the \textit{glmmBUGS} function and it generates the starting values for the simulation. 
\verb!parameters.to.save! is a character vector of the names of the parameters to be saved.
\verb!model.file! is the file which contains the code used for WinBUGS
\verb!n.chain! denotes how many chains used to ran for the simulation, it is $3$ as default.
\verb!n.iter! denotes the number of total iterations per chain; 
\verb!n.burnin! denotes number of iterations to discard at the beginning; 
\verb!n.thin! denotes the thinning rate. So for our example, we will get $270$ simulation results.

As we run the \verb!bugs! function, a winbugs window will open and simulate from the posterior distribution.

All the results are now stored in \verb!bacResult!, which is in a format that is difficult to interpret, we need to use  \verb!restoreParams! function to restore the parameters: 

\begin{Schunk}
\begin{Sinput}
> bacParams = restoreParams(bacResult, bacrag$ragged)
> names(bacParams)
\end{Sinput}
\begin{Soutput}
[1] "intercept" "SDID"      "deviance"  "RID"       "betas"    
\end{Soutput}
\end{Schunk}


The ''intercept'' column contains $270$ values of simulated intercept values. 
''SDID'' is the standard deviation of patient's ID. 
''RID'' is the non-spatial effect, i.e $V_i$
''betas'' are the simulated estimates of the coefficients of treatment and number of weeks. 

To summarize all the results, so that it will be easier for us to retrieve information from the simulation, the \verb!summaryChain! is used: 

\begin{Schunk}
\begin{Sinput}
> bacsummary = summaryChain(bacParams)
> names(bacsummary)
\end{Sinput}
\begin{Soutput}
[1] "scalars" "RID"     "betas"  
\end{Soutput}
\end{Schunk}
\verb!bacsummary! contains the three sets of results: scalars, RID and betas. Each result has the mean value, standard deviation value, p-value and the confidence interval values on different scale levels for the parameters stored in the \verb!restoreParams! function. 
For example, the ''betas'' gives the following results:

\begin{Schunk}
\begin{Sinput}
> bacsummary$betas
\end{Sinput}
\begin{Soutput}
                   mean       pval         sd       0.5%       2.5%       5%
observations -0.1574366 0.00000000 0.05511219 -0.2918435 -0.2612825 -0.24682
trtdrug      -1.4662361 0.01851852 0.84390002 -4.3422900 -3.2321750 -2.79575
trtdrugplus  -0.8611073 0.14074074 0.78408035 -2.7885850 -2.4846250 -2.07690
                 50%       95%      97.5%       99.5%
observations -0.1587 -0.065248 -0.0485150 -0.03103385
trtdrug      -1.4580 -0.180630 -0.0755310  0.30390050
trtdrugplus  -0.9277  0.445640  0.6658175  1.30121600
\end{Soutput}
\end{Schunk}

In order to check the convergency of the simulation, we use \verb!checkChain! function to do the chain plot:
\begin{Schunk}
\begin{Sinput}
> checkChain(bacParams)
\end{Sinput}
\end{Schunk}

\begin{figure}[ht]
\begin{center}
 <<fig=TRUE, echo = FALSE, width=12, height=6>>=
 chechChain(bacParams)
 @
 \caption{A chain plot of the posterial distribution from MCMC simulation for the non-spatial model.}\label{chain}
 \end{center}
\end{figure}

The plot is shown in Figure \ref{chain}. The three lines (red, green and black lines) converged, this means the simulation result are stable. 



\subsection{Spatial Model} 
We then introduce the spatial model. The data set is built in the \textit{glmmBUGS} package. 

<<thedata>>
head(ontario)

$CSDUID$ is the census tract number; 
$Observed$ is the number of cancer cases; 
$logExpected$ is the predicted number of cancer cases on the $\log$ scale.

Consider the following model:

\[Y_{i} \sim  Poisson(\lambda_i)\]
\[\log(\lambda_{i}) = \mu + U_i + V_i+ \log{O_i}\]
\[U_i \sim GMRF(0, \sigma_U^2)\]
\[V_i \sim iid N(0, \sigma_V^2)\] 

where $Y_{i}$ is the number of cancer cases from census $i$. 
$\lambda_{i}$ is the rate of disease of the $ith$ region, it is the mean and variance of the poisson distribution; 
$\mu$ is the average of disease rate when other effects were not in the consideration.
$U_i$ denotes the spatial term, it follows a gussian markov random field with mean equals $0$ and variance $\sigma_U^2$; 
$V_i$ denotes the non-spatial term, it follows an identical independent distribution with mean equals $0$ and variance equals $\sigma_V^2$; 
$\log{O_ij}$ is the offset of the $ith$ region.


To aid convergence, the bugs model is fitting the following reparametrized model:
\[Y_{i} \sim  Poisson(\lambda_i)\]
\[\log(\lambda_i) = R_i+ \log{O_i}\]
\[R_i \sim N(U_i + \mu, \sigma_U^2)\]
\[U_i \sim GMRF(0, \sigma_U^2)\]
\[V_{i} = R_i - U_i \sim iid N(0, \sigma_V^2)\] 

The spatial term $U_i$ in the model accounts the effects from neighbours. A adjancy matrix computed by the \verb!poly2nb! function from the \verb!spdep! library.is used to denote this neighbourhood structure.

\begin{verbatim}
library(spdep)
data(popdata)
popDataAdjMat = poly2nb(popdata, as.character(popdata[["CSDUID"]]))
\end{verbatim}

Then we fit a glmmBUGS model: 
\begin{Schunk}
\begin{Sinput}
> data(ontario)
> data(popDataAdjMat)
> forBugs = glmmBUGS(formula = Observed + logExpected ~ 1, effects = "CSDUID", 
+     family = "poisson", spatial = popDataAdjMat, data = ontario)
\end{Sinput}
\end{Schunk}

The $\log$ of the expected values of cancer cases are taken as offset value; The spatial terms takes the neighbourhood structure, which is the adjancy matrix. The random effect is the region ID.

Then we use the \verb!bugs! function in the \verb!R2 WindBUGS! package to do the MCMC simulation as: 
\begin{Schunk}
\begin{Sinput}
> startingValues = forBugs$startingValues
> source("getInits.R")
> library(R2WinBUGS)
> ontarioResult = bugs(forBugs$ragged, getInits, parameters.to.save = names(getInits()), 
+     model.file = "model.bug", n.chain = 3, n.iter = 6000, n.burnin = 100, 
+     n.thin = 50, program = "winbugs")
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> ontarioParams = restoreParams(ontarioResult, forBugs$ragged)
> names(ontarioParams)
\end{Sinput}
\begin{Soutput}
[1] "intercept"        "SDCSDUID"         "SDCSDUIDSpatial"  "deviance"        
[5] "RCSDUID"          "RCSDUIDSpatial"   "FittedRateCSDUID"
\end{Soutput}
\end{Schunk}

Compare the paramters we got from the spatial model with the parameters from the non-spatial model. 
There are three extra terms: SDCSUIDSpatial, RCSUIDSpatial and FittedRateCSDUID.

SDCSUIDSpatial     The standard deviation of the spatial effects for each region.
RCSDUIDSpatial     The spatial random effect for each region. 
FittedRateCSDUID   The incident rate relative to the population average. Note that these rates are on the natural scale rather than the log scale. 

%RCSDUID            The log relative risk, which is the sum of the spatial and non-spatial random effect, i.e $U_i + V_i$. 

\begin{Schunk}
\begin{Sinput}
> ontarioSummary = summaryChain(ontarioParams)
> checkChain(ontarioParams)
\end{Sinput}
\end{Schunk}

\begin{figure}[ht]
 \centering
 <<fig=TRUE, width=12, height=6>>=
 chechChain(ontarioParams)
 @
 \caption{A chain plot of the posterior distribution from MCMC simulation for the spatial model.}\label{chainspatial}
\end{figure}

Figure \ref{chainspatial} shows the chain plots for the spatial model. The sdandard deviation of the region and spatial effect converged well, but the intercept values doesn't converge well. In general, the three chains did not converge well due to size of the simulation, this means the predicted value is not stable.

\section{Summary}
The functions in the \verb!glmmBUGS! package can fit both non-spatial and spatial models. 
The package connects two statistical softwares, R and WinBUGS, to finish a two-step job: model fitting and MCMC simulation. 
Together with the \verb!mergeBugsData! function in the \verb!diseasemapping! package, the result from the MCMC simulation can be merged with the original population data set. This step allow us to draw disease maps in R or GIS softwares. 

\section{Acknowledgments}


\section{Bibliography}

\end{document}



