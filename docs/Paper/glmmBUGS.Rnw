\documentclass[a4paper]{report}
\usepackage{graphicx,amsmath}
\usepackage{RJournal}
\usepackage[round]{natbib}
\bibliographystyle{abbrvnat}
\DeclareMathOperator{\logit}{logit}


\usepackage{Sweave}

\SweaveOpts{height=3,width=5}
\setkeys{Gin}{width=0.45\textwidth}

\begin{document}


\begin{article}
\title{MCMC for Generalized Linear Mixed Models with glmmBUGS}
\author{by Patrick Brown and Lutong Zhou}
\maketitle
<<options,echo=false>>=
options(SweaveSyntax="SweaveSyntaxNoweb", SweaveHooks=list(fig=function() par(mar=c(2.0,2.0,.2,.1), mgp=c(1, 0.3, 0), cex=0.5)), width=45)
@

\section{Introduction}
The \pkg{glmmBUGS} package is a bridging tool between Generalized Linear Mixed Models (GLMM's) in R and the BUGS language \citep{winbugs}.  It provides a simple way of performing Bayesian inference using Markov chain Monte Carlo (MCMC) methods \cite[see][]{gelman}.  In the past, there were two time consuming steps required for using WinBUGS compared to fitting models within R.  First, unbalanced multi-level data needs to be formatted in a way which BUGS can handle, including changing categorical variables to indicator variables.  Second, a BUGS model file must be written.  The package addresses these issues by allowing users to specify models as formulas in R, as they would in the \command{glm} function, and provides everything necessary for fitting the model with WinBUGS or OpenBUGS via the  \pkg{R2WinBUGS} package \citep{r2winbugs}. 

\pkg{glmmBUGS} creates the necessary BUGS model file, starting value function, and suitably formatted data.
 Improved chain mixing is accomplished with a simple reparametrization and the use of sensible starting values.  
 Functions are provided for formatting and summarizing the results.  Although a variety of models can be implemented entirely within \pkg{glmmBUGS}, the package intends to provide a basic set of data and files for users to modify as necessary.  This allows the full flexibility of BUGS model specification to be exploited, with much of the initial ``grunt work'' being taken care of by \pkg{glmmBUGS}.



\section{Examples}

\subsection{Independent random effects} 
Consider the bacteria data from the \pkg{MASS} package: 
<<thedata1>>=
library(MASS)
data(bacteria)
head(bacteria)
@
The variables to be considered are: \var{y}, the presence or absence of bacteria in a sample coded as `y' and `n' respectively; \var{week}, the time of the observation; $ID$, subject identifier; and \var{trt} giving the treatment group as `placebo', `drug', or `drug+'.  

A generalized linear mixed model is applied to the data with:
\begin{align}\nonumber
Y_{ij} \sim & \text{Bernoulli}(p_{ij})\\ \nonumber
\logit(p_{ij}) = &\mu + x_{ij}\beta + V_{i}\\ \label{eq:model}
V_{i} \sim iid &\text{\ N}(0, \sigma^2) 
\end{align}
where: $Y_{ij}$ is the presence or absence of bacteria of $i$th person at week $j$; covariates $x_{ij}$ are week and indicator variables for treatment;
$p_{ij}$ denotes the probability if bacteria presence; $V_i$ is the random effect for $i$th patient, which i.i.d.\ normal with variance $\sigma^2$.
To improve the mixing of the MCMC, a reparameterized model is fit with:
\begin{align}\nonumber
Y_{ij} \sim&  \text{Bernoulli}(p_{ij})\\ \nonumber
\logit(p_{ij}) =& R_{i} + w_{ij} \gamma \\ \label{eq:modelReparam}
R_{i} \sim& \text{N}(\mu + g_{i}\alpha, \sigma^2).
\end{align}
Here $g_i$ is the (indicator variables for) treatment group for subject $i$ and $w_{ij}$ is the week observation $j$ was taken.  Not that the two models are the same, with $V_i = R_{i} - \mu - g_{i}\alpha$, $\beta = (\gamma, \alpha)$ and $x_{ij} = (w_{ij}, g_i)$.  The model in (\ref{eq:model}) has strong negative dependence between the posterior samples of the $V_i$ and $\mu$, whereas the $R_i$ and $\mu$ in (\ref{eq:modelReparam}) are largely independent.

As BUGS only allows numeric data, and cannot have the '+' sign in variable names, the data are recoded as follows:
<<thechange>>=
bacterianew <- bacteria
bacterianew$yInt = as.integer(bacterianew$y=="y")
levels(bacterianew$trt) <- c("placebo", "drug", "drugplus")
@

The primary function in the package is \command{glmmBUGS}, which does the preparatory work for fitting the model in (\ref{eq:modelReparam}) with: 
<<bacrag>>=
library(glmmBUGS)
bacrag <- glmmBUGS(yInt ~ trt + week , data=bacterianew, effects = "ID", 
                                                 family= "bernoulli") 
@
This specifies \var{yInt} as a Bernoulli-valued response, \var{trt} and \var{week} as fixed-effect covariates, and the \var{ID} column for the random effects.  The result is a list with three elements:
\begin{description}
\item[\var{ragged}] is a list containing the data to be passed to WinBUGS;
\item[\var{pql}] is the results from fitting the model with \command{glmmPQL} from the \pkg{MASS} package.
\item[\var{startingValues}] is a list of starting values for the parameters and random effects, which is obtained from the \command{glmmPQL} result.
\end{description}  
In addition, two files are written to the working directory
\begin{description}
\item[\file{model.bug}] the BUGS model file
\item[\file{getInits.R}] R code for a function to generate random starting values.
\end{description}  

  To accommodate unbalanced designs, the data are stored as `ragged arrays', described as `offsets' in the section ``Handling unbalanced datasets" of the WinBUGS manual.  The \var{ragged} result has a vector element $SID$ indicating the starting position of each individual's observations in the dataset.   The covariates are split into elements $XID$ and $Xobservations$ for the individual-level and observation-level covariates respectively:
<<raggedNames>>=
names(bacrag$ragged)
@
The model file consists of an outer loop over \var{ID} levels and an inner loop over observations.  The details of how the model is implemented are best understood by examining the \file{model.bug} file and consulting the WinBUGS manual.


At this stage the user is expected to modify the files and, if necessary, the data to refine the model, set appropriate priors, and ensure suitability of starting values.
Before using the \command{bugs} function in the \pkg{R2WinBUGS} package to sample from the posterior, the starting values \command{getInits} function must be prepared.  First, the file \file{getInits.R} (which contains the source for \command{getInits}) should be edited and sourced into R.  Next, the list containing the PQL-derived starting values must be assigned the name \var{startingValues}, as \command{getInits} will be accessing this object every time it is run.
<<thebug>>=
source("getInits.R")
startingValues = bacrag$startingValues
library(R2WinBUGS)
bacResult = bugs(bacrag$ragged, getInits, parameters.to.save = names(getInits()),
                 n.chain=3, 
                 n.iter=100, n.burnin=20, n.thin=4)
@


As the results stored in \var{bacResult} are based on the reparametrized model, we use  \command{restoreParams} to restore the original parametrization from (\ref{eq:model}). 

<<theparam>>=
bacParams = restoreParams(bacResult, bacrag$ragged) 
names(bacParams)
@ 
The result is posterior samples for $\mu$ ($intercept$), $\sigma$ ($SDID$), all the $V_i$ ($RID$), and $\beta$ ($betas$).  Posterior means and credible intervals are obtained by:
<<thesummary>>=
bacsummary = summaryChain(bacParams)
names(bacsummary)
bacsummary$betas[,c("mean", "2.5%", "97.5%")]
@              
The coefficient on \var{week} is denoted `observations' in the results, as it is the only covariate which is assigned to observations (as opposed to ID's).       

In order to check the convergence of the simulations, we use the \command{checkChain} function to produce trace plots:
<<thechain, fig=true>>=
checkChain(bacParams, c("intercept", "SDID"))
@
% \caption{A chain plot of the posterial distribution from MCMC simulation for the non-spatial model.}\label{chain}



\subsection{A spatial example} 
The \var{ontario} dataset contains expected an observed counts of molar cancer by census sub-division in Ontario, Canada.
<<thedata>>=
data(ontario)
head(ontario)
@

Consider the following model \cite[see][]{GMRFbook}:
\begin{align}\nonumber
Y_{i} \sim  &\text{Poisson}(\lambda_i E_i)\\ \nonumber
\log(\lambda_{i}) = &\mu + U_i + V_i\\ \nonumber
U_i \sim &\text{GMRF}(\sigma_U^2)\\ \label{eq:spatial}
V_i \sim & \text{iid N}(0, \sigma_V^2)
\end{align} 
where $Y_{i}$ and $E_i$ are the observed and expected number  of cancer cases in census division $i$; 
$\lambda_{i}$ is the cancer rate;
$U_i$ is a spatial random effect, a Gaussian Markov random field with variance $\sigma_U^2$; and
$V_i$ is spatially independent random effect with variance $\sigma_V^2$. 


This model is also reparametrised with $R_i \sim N(U_i + \mu, \sigma_V^2)$ replacing $V_i$.  
An adjacency matrix is required for the spatial random effect, this was computed from the spatial boundary files with the \command{poly2nb} function from the \command{spdep} package and is stored as the {\tt popDataAdjMat} object.

{\tt glmmBUGS} can be used to fit this model as follows: 
<<theragged>>=
data(popDataAdjMat)
forBugs = glmmBUGS(formula=observed + logExpected ~ 1,
  effects="CSDUID", family="poisson", spatial=popDataAdjMat,
  data=ontario)
@

Notice the expected counts are needed on the log scale, and are passed as a second argument on the left side of the model equation to denote their being offset parameters without a coefficient.  The random effect is at the census sub-division level (CSDID), with {\tt popDataAdjMat} giving the dependency structure.  Posterior samples can be generated as follows: 
<<thebugs>>=
startingValues = forBugs$startingValues
source("getInits.R")
library(R2WinBUGS)
onResult = bugs(forBugs$ragged, getInits, parameters.to.save = names(getInits()),
   n.chain=3, n.iter=600, n.burnin=60, n.thin=5,
       program="winbugs")
ontarioParams = restoreParams(onResult, forBugs$ragged)
names(ontarioParams)
@     

There are posterior simulations for two variance parameters, $\sigma_U$ (SDCSDUIDSPATIAL) and $\sigma_V$ (SDCSDUID).  Samples for the random effects are given for $U_i$ (RCSDUIDSpatial), $U_i +V_i$ (RCSDUID), and $\lambda_i$ (FittedRateCSDUID).  



%\begin{figure}[ht]
% \centering
<<checkChainSpatial, fig=true>>=
checkChain(ontarioParams, c("SDCSDUIDSpatial", "SDCSDUID")) 
@
% \caption{A chain plot of the posterior distribution from MCMC simulation for the spatial model.}\label{chainspatial}
%\end{figure}

These trace plots show poor mixing, and the MCMC should be re-run with longer chains and more thinning.

The {\tt diseasemapping} package has facilities for merging BUGS results into spatial datasets, producing the map below.  

<<ontarioMap, echo=false, fig=true,height=6,width=6>>=
library(diseasemapping)
require(RColorBrewer)
data(popdata)
ontarioSummary = summaryChain(ontarioParams)
newdata =mergeBugsData(popdata, ontarioSummary)
therange =range(newdata$RCSDUID.mean)
print(spplot(newdata, "RCSDUID.mean", col.regions=brewer.pal(7, "OrRd"), cuts=6, lwd=0))

@


\section{Summary}

There are a number of methods and R packages for performing Bayesian inference on generalized liner mixed models, including \pkg{geoRglm} \citep{georglm}.  Particularly noteworthy is the \pkg{INLA} package which avoids the use of MCMC by using Laplace approximations, as described in \citet{ruelaplace}.  Despite this, many researchers working with R (including the authors) continue to use WinBUGS for model fitting.  This is at least partly due to the flexibility of the BUGS language, which gives the user nearly full control over specification of distributions and dependence structures.  This package aims to retain this flexibility by providing files to be edited before model fitting is carried out, rather than providing a large number of options for, i.e. prior distributions.  More model-specific packages such as \pkg{INLA} are entirely adequate (and perhaps preferable) for the two examples presented here.   Those who wish to have full control over priors or build more complex multivariate or errors-in-covariate models will likely appreciate the head start which \pkg{glmmBUGS} can provide for these tasks.


\section*{Acknowledgements}


\bibliography{glmmBUGS}


\vspace{10pt}

\noindent \emph{Patrick Brown\\
Dalla Lana School of Public Health,\\ University of Toronto, and\\
Cancer Care Ontario, Canada\\}
\verb!patrick.brown@utoronto.ca!

\vspace{10pt}

\noindent \emph{Lutong Zhou\\
Cancer Care Ontario, Canada\\}
\verb!carly_zhou@hotmail.com!


\end{article}
\end{document}



