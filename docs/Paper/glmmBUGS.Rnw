\documentclass[a4paper]{report}
\usepackage{graphicx,amsmath}
\usepackage{RJournal}
\usepackage[round]{natbib}
\bibliographystyle{abbrvnat}
\DeclareMathOperator{\logit}{logit}

\begin{document}


\begin{article}
\title{An Introduction to glmmBUGS Package}
\author{lutong and patrick}
\maketitle


\section{Introduction}
The {\tt glmmBUGS} package is a bridging tool between Generalized Linear Mixed Models (GLMM's) in R and the BUGS language for  Bayesian analysis using Markov chain Monte Carlo (MCMC) methods.  The package allows users to specify models as formulas in R, as they would in the {\tt glm} function.  It creates the necessary BUGS model file, starting value function, and suitably formatted data for performing inference in WinBUGS or BRugs with the {\tt R2WinBUGS} package.  Some reparametrizing of the model is done to assist in mixing and convergence of the chains, and functions are provided for formatting and summarizing the results.  Although a variety of models can be implemented entirely within {\tt glmmBUGS}, the package intends to provide a basic set of data and files for users to modify as necessary.  This allows the full flexibility of BUGS model specification to be exploited, with much of the initial ``grunt work'' being taken care of by {\tt glmmBUGS}.

\section{Examples}

\subsection{Independent random effects} 
Consider the bacteria data from the \verb!MASS! package: 
<<thedata1>>=
library(MASS)
data(bacteria)
head(bacteria)
@
The variables to be considered are: $y$, the presence or absence of bacteria in a sample coded as `y' and `n' respectively; $week$, the time of the observation; $ID$, subject identifier; and $trt$ giving the treatment group as `placebo', `drug', or `drug+'.  

A generalized linear mixed model is applied to the data with:
\begin{align}\nonumber
Y_{ij} \sim & \text{Bernoulli}(p_{ij})\\ \nonumber
\logit(p_{ij}) = &\mu + x_{ij}\beta + V_{i}\\ \label{eq:model}
V_{i} \sim iid &\text{N}(0, \sigma^2) 
\end{align}
where: $Y_{ij}$ is the presence or absence of bacteria of $i$th person at week $j$; covariates $x_{ij}$ are week and indicator variables for treatment;
$p_{ij}$ denotes the probability if bacteria presence; $V_i$ is the random effect for $i$th patient, which i.i.d.\ normal with variance $\sigma^2$.
To improve the mixing of the MCMC, a reparameterized model is fit with:
\begin{align}\nonumber
Y_{ij} \sim&  \text{Bernoulli}(p_{ij})\\ \nonumber
\logit(p_{ij}) =& R_{i} + w_{ij} \gamma \\ \label{eq:modelReparam}
R_{i} \sim& \text{N}(\mu + g_{i}\alpha, \sigma^2).
\end{align}
Here $g_i$ is the (indicator variables for) treatment group and $w_{ij}$ is the week.  Not that the two models are the same, with $V_i = R_{i} - \mu - g_{i}\alpha$ and $\beta = (\gamma, \alpha)$.  The former model has strong dependence between the posterior samples of the $V_i$ and $\mu$, whereas the $R_i$ and $\mu$ are largely independent.

As BUGS only allows numeric data, and cannot have the `+' sign in variable names, the data are recoded as follows:
<<thechange>>=
bacterianew <- bacteria
bacterianew$yInt = as.integer(bacterianew$y=="y")
levels(bacterianew$trt) <- c("placebo", "drug", "drugplus")
@

The primary function in the package is \verb!glmmBUGS!, which does the preparatory work for fitting the model in \ref{eq:modelReparam} with: 
<<bacrag>>=
library(glmmBUGS)
bacrag <- glmmBUGS(yInt ~ trt + week , data=bacterianew, effects = "ID", 
                                                 family= "bernoulli", modelFile="bacmodel.bug") 
@
This specifies $yInt$ as a Bernoulli-valued response, $trt$ and $week$ as fixed-effect covariates, and the $ID$ column for the random effects.  The result is a list with three elements:
\begin{description}
\item[ragged] is a list containing the data to be passed to WinBUGS;
\item[pql] is the results from fitting the model with \verb!glmmPQL! from the \verb!MASS! package.
\item[startingValues] is a list of starting values for the parameters and random effects, which is obtained from the \verb!glmmPQL! result.
\end{description}  
In addition, two files are written to the working directory
\begin{description}
\item[bacmodel.bug], the BUGS model file
\item[getInits.R], R code for a function to generate random starting values.
\end{description}  

At this stage the user is expected to modify the files and, if necessary, the data to refine the model, set appropriate priors, and ensure suitability of starting values.  To accommodate unbalanced designs, the data are stored as `ragged arrays', described as `offsets' in the section ``Handling unbalanced datasets" of the WinBUGS manual.  The {\tt ragged} result has a vector element $SID$ indicating the starting position of each individual's observations in the dataset.   The covariates are split into elements $XID$ and $Xobservations$ for the individual-level and observation-level covariates respectively:
<<raggedNames>>=
names(bacrag$ragged)
@
The model file consists of an outer loop over $ID$ levels and an inner loop over observations.  The details of how the model is implemented are best understood by examining the `model.bug' file and consulting the WinBUGS manual.

Before using the \verb!bugs! function in the \verb!R2WinBUGS! package to sample from the posterior, the starting values will be prepared by: sourcing in the R code containing the {\tt getInits} function to generate random starting values; and saving PQL-derived starting values with the name {\tt startingValues}, which this function is expecting.
<<thebug>>=
source("getInits.R")
startingValues = bacrag$startingValues
library(R2WinBUGS)
bacResult = bugs(bacrag$ragged, getInits, parameters.to.save = names(getInits()),
                 model.file="bacModel.bug", n.chain=3, 
                 n.iter=500, n.burnin=50, n.thin=50, program="winbugs")
@


As the results stored in \verb!bacResult! are based on the reparametrized model, we use  \verb!restoreParams! to restore the orignial parametrization from \ref{eq:model}. 

<<theparam>>=
bacParams = restoreParams(bacResult, bacrag$ragged) 
names(bacParams)
@ 
The result is posterior samples for $\mu$ ($intercept$), $\sigma$ ($SDID$), all the $V_i$ ($RID$), and $\beta$ ($betas$).  Posterior means and credible intervals are obtanied by:
<<thesummary>>=
bacsummary = summaryChain(bacParams)
names(bacsummary)
bacsummary$betas[,c("mean", "2.5%", "97.5%")]
@                     

In order to check the convergence of the simulations, we use the \verb!checkChain! function to produce trace plots:
<<thechain, fig=true>>=
#checkChain(bacParams, c("intercept", "SDID"))
matplot(bacParams$intercept)
@
% \caption{A chain plot of the posterial distribution from MCMC simulation for the non-spatial model.}\label{chain}



\subsection{A spatial example} 
The {\tt ontario} dataset contains expected an observed counts of molar cancer by census sub-division in Ontario, Canada.
<<thedata>>=
data(ontario)
head(ontario)
@

Consider the following model:
\begin{align}\nonumber
Y_{i} \sim  &\text{Poisson}(\lambda_i E_i)\\ \nonumber
\log(\lambda_{i}) = &\mu + U_i + V_i\\ \nonumber
U_i \sim &\text{GMRF}(\sigma_U^2)\\ \label{eq:spatial}
V_i \sim & \text{iid N}(0, \sigma_V^2)
\end{align} 
where $Y_{i}$ and $E_i$ are the observed and expected number  of cancer cases in census division $i$; 
$\lambda_{i}$ is the cancer rate;
$U_i$ is a spatial random effect, a Gaussian Markov random field with variance $\sigma_U^2$; and
$V_i$ is spatially independent random effect with variance $\sigma_V^2$. 


This model is also reparametrised with $R_i \sim N(U_i + \mu, \sigma_V^2)$ replacing $V_i$.  
An adjacency matrix is required for the spatial random effect, this was computed from the spatial boundary files with the \verb!poly2nb! function from the \verb!spdep! package and is stored as the {\tt popDataAdjMat} object.

{\tt glmmBUGS} can be used to fit this model as follows: 
<<theragged>>=
data(popDataAdjMat)
forBugs = glmmBUGS(formula=observed + logExpected ~ 1,
  effects="CSDUID", family="poisson", spatial=popDataAdjMat,
  data=ontario)
@

Notice the expected counts are needed on the log scale, and are passed as a second argument on the left side of the model equation to denote their being offset parameters without a coefficient.  The random effect is at the census sub-division level (CSDID), with {\tt popDataAdjMat} giving the dependency structure.  Posterior samples can be generated as follows: 
<<thebugs>>=
startingValues = forBugs$startingValues
source("getInits.R")
library(R2WinBUGS)
ontarioResult = bugs(forBugs$ragged, getInits, parameters.to.save = names(getInits()),
   n.chain=3, n.iter=600, n.burnin=60, n.thin=5,
       program="winbugs")
ontarioParams = restoreParams(ontarioResult, forBugs$ragged)
names(ontarioParams)
@     

There are posterior simulations for two variance parameters, $\sigma_U$ (SDCSDUIDSPATIAL) and $\sigma_V$ (SDCSDUID).  Samples for the random effects are given for $U_i$ (RCSDUIDSpatial), $U_i +V_i$ (RCSDUID), and $\lambda_i$ (FittedRateCSDUID).  



%\begin{figure}[ht]
% \centering
<<checkChainSpatial, fig=true>>=
checkChain(ontarioParams, c("SDCSDUIDSpatial", "SDCSDUID")) 
@
% \caption{A chain plot of the posterior distribution from MCMC simulation for the spatial model.}\label{chainspatial}
%\end{figure}

These trace plots show poor mixing, and the MCMC should be re-run with longer chains and more thinning.

The {\tt diseasemapping} package has facilities for merging BUGS results into spatial datasets, producing the map below.  

<<ontarioMap, echo=false, fig=true>>=
library(diseasemapping)
data(popdata)
ontarioSummary = summaryChain(ontarioParams)
newdata =mergeBugsData(popdata, ontarioSummary)
print(spplot(newdata, "RCSDUID.mean"))
@


\section{Summary}



The functions in the \verb!glmmBUGS! package can fit both non-spatial and spatial models. 
The package connects two statistical softwares, R and WinBUGS, to finish a two-step job: model fitting and MCMC simulation. 
Together with the \verb!mergeBugsData! function in the \verb!diseasemapping! package, the result from the MCMC simulation can be merged with the original population data set. This step allow us to draw disease maps in R or GIS softwares. 

\section{Acknowledgments}


\section{Bibliography}
\end{article}
\end{document}



